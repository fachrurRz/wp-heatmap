'use strict';

var _constants = require('./_constants');

var _stringHash = require('string-hash');

var _stringHash2 = _interopRequireDefault(_stringHash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var loaderUtils = require('loader-utils');
var NodeTemplatePlugin = require('webpack/lib/node/NodeTemplatePlugin');
var NodeTargetPlugin = require('webpack/lib/node/NodeTargetPlugin');
var LibraryTemplatePlugin = require('webpack/lib/LibraryTemplatePlugin');
var SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');
var LimitChunkCountPlugin = require('webpack/lib/optimize/LimitChunkCountPlugin');

function btoa(str) {
  var buffer = null;
  if (str instanceof Buffer) {
    buffer = str;
  } else {
    buffer = new Buffer(str.toString(), 'binary');
  }
  return buffer.toString('base64');
}

global.btoa = btoa;

module.exports = function (source) {
  // eslint-disable-line func-names
  if (this.cacheable) {
    this.cacheable();
  }
  return source;
};

module.exports.pitch = function (request) {
  var _this = this;

  // eslint-disable-line func-names
  if (this.cacheable) {
    this.cacheable();
  }
  var query = loaderUtils.getOptions(this) || {};
  this.addDependency(this.resourcePath);
  var childFilename = 'extract-text-webpack-plugin-output-filename';
  var publicPath = typeof query.publicPath === 'string' ? query.publicPath : this._compilation.outputOptions.publicPath;
  var outputOptions = {
    filename: childFilename,
    publicPath: publicPath
  };
  var childCompiler = this._compilation.createChildCompiler('extract-text-webpack-plugin', outputOptions);
  childCompiler.apply(new NodeTemplatePlugin(outputOptions));
  childCompiler.apply(new LibraryTemplatePlugin(null, 'commonjs2'));
  childCompiler.apply(new NodeTargetPlugin());
  childCompiler.apply(new SingleEntryPlugin(this.context, '!!' + request));
  childCompiler.apply(new LimitChunkCountPlugin({ maxChunks: 1 }));

  var source = void 0;
  childCompiler.plugin('after-compile', function (compilation, callback) {
    source = compilation.assets[childFilename] && compilation.assets[childFilename].source();

    // Remove all chunk assets
    compilation.chunks.forEach(function (chunk) {
      chunk.files.forEach(function (file) {
        delete compilation.assets[file];
      });
    });

    callback();
  });

  var callback = this.async();
  childCompiler.runAsChild(function (err, entries, compilation) {
    if (err) {
      return callback(err);
    }

    if (compilation.errors.length > 0) {
      return callback(compilation.errors[0]);
    }
    compilation.fileDependencies.forEach(function (dep) {
      // eslint-disable-line
      this.addDependency(dep);
    }, _this);
    compilation.contextDependencies.forEach(function (dep) {
      // eslint-disable-line
      this.addContextDependency(dep);
    }, _this);
    if (!source) {
      return callback(new Error("Didn't get a result from child compiler"));
    }
    try {
      var text = _this.exec(source, request);
      var css = text.toString();
      // eslint-disable-next-line callback-return
      callback(null, ['module.exports = ' + JSON.stringify(text.locals || {}) + ';', 'module.exports.' + _constants.STYLE_ID_PROP_NAME + ' = ' + JSON.stringify((0, _stringHash2.default)(css)) + ';', 'module.exports.' + _constants.STYLE_CHILD_PROP_NAME + ' = ' + JSON.stringify(css) + ';'].join('\n'));
    } catch (e) {
      return callback(e);
    }
  });
};